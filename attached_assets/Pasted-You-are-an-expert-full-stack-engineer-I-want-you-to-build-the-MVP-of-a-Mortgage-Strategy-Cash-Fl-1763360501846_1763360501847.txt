You are an expert full-stack engineer. I want you to build the MVP of a **Mortgage Strategy, Cash-Flow Planning & Wealth Forecasting** app, targeting **Canadian mortgages**, as a full-stack web app.

Use this tech stack:

- Backend: Python FastAPI
- DB: SQLite with SQLAlchemy (or equivalent ORM)
- Frontend: React + TypeScript + Vite
- API style: JSON REST
- Charts: a simple library like Recharts or Chart.js

Please:

- Set up a monorepo-style structure with `backend/` and `frontend/` folders.
- Implement core data models, API endpoints, and UI pages.
- Focus on **clean architecture and modular design**.
- Prioritize correctness of mortgage math and projections.

===============================================================================
HIGH-LEVEL PRODUCT DESCRIPTION (MVP)
===============================================================================

Build an MVP for a web app that helps a Canadian homeowner:

1. Model their **mortgage** (fixed + variable) with rate changes.
2. Model their **monthly cash flow** (income, expenses, debts).
3. Define a **prepayment strategy** (lump-sum, extra payments, double-up).
4. Build and cap an **Emergency Fund (EF)**.
5. Model **investment growth** with surplus cash.
6. See **net worth projections** over 10–30 years.
7. Create and compare multiple **scenarios** (e.g., “Aggressive Prepay”, “Invest More”, “Balanced”).
8. Answer the key question: **“Prepay vs invest, which strategy wins for net worth?”**

MVP scope should include everything above. AI advisor / PDF exports / multi-property rentals are NOT part of this MVP.

===============================================================================
ARCHITECTURE & PROJECT STRUCTURE
===============================================================================

Create this structure (or something close):

- backend/
  - main.py (FastAPI entrypoint)
  - models.py (SQLAlchemy models)
  - schemas.py (Pydantic models)
  - database.py (session, engine, etc.)
  - routers/
    - scenarios.py
    - calculations.py
  - services/
    - mortgage_engine.py
    - cashflow_engine.py
    - ef_engine.py
    - investment_engine.py
    - prepayment_engine.py
    - networth_engine.py
- frontend/
  - src/
    - main.tsx
    - App.tsx
    - api/ (API client)
    - pages/
      - DashboardPage.tsx
      - ScenarioListPage.tsx
      - ScenarioEditorPage.tsx
      - ComparisonPage.tsx
    - components/
      - ScenarioForm.tsx
      - MortgageForm.tsx
      - CashFlowForm.tsx
      - EFForm.tsx
      - InvestmentForm.tsx
      - PrepaymentForm.tsx
      - Charts/ (NetWorthChart, CashFlowChart, etc.)

You don’t need to be perfect, but keep backend and frontend cleanly separated.

===============================================================================
CORE DOMAIN ENTITIES & DATA MODEL
===============================================================================

Use SQLite, with at least these tables/entities:

1. Scenario
   - id (int, primary key)
   - name (string)
   - description (string, optional)
   - created_at (datetime)
   - updated_at (datetime)
   - horizon_years (int, default 10)

2. MortgageConfig
   - id
   - scenario_id (FK -> Scenario)
   - home_price (float)
   - down_payment (float)
   - principal (float)  # can be derived but store for convenience
   - amortization_years (int)
   - amortization_months (int, optional)
   - term_years (int)  # initial term, e.g., 5 years
   - payment_frequency (enum: MONTHLY, BIWEEKLY, ACCELERATED_BIWEEKLY)
   - mortgage_type (enum: FIXED, VARIABLE_CHANGING_PAYMENT, VARIABLE_FIXED_PAYMENT)
   - compounding (enum: SEMI_ANNUAL, MONTHLY; default SEMI_ANNUAL for Canada)
   - property_appreciation_rate (float, annual, %, default 2.0)

3. RateScheduleBlock
   - id
   - mortgage_id (FK -> MortgageConfig)
   - start_year_offset (int)  # e.g. 0 for start, 5 for after 5 years
   - end_year_offset (int)
   - rate_type (enum: FIXED, PRIME_PLUS_SPREAD)
   - fixed_rate (float, nullable)
   - prime_spread (float, nullable)

4. PrimeRateBlock
   - id
   - mortgage_id (FK -> MortgageConfig)
   - start_year_offset (int)
   - end_year_offset (int)
   - prime_rate (float)  # annual rate

5. CashFlowConfig
   - id
   - scenario_id (FK)
   - monthly_income (float)           # base salary from two paycheques
   - extra_paycheques_per_year (int)  # usually 2 in Canada
   - annual_bonus (float)
   - fixed_expenses_monthly (float)   # taxes, insurance, condo, etc.
   - variable_expenses_monthly (float)# groceries, gas, entertainment, etc.
   - other_debt_payments_monthly (float)

6. EFConfig (Emergency Fund)
   - id
   - scenario_id (FK)
   - target_amount (float)            # e.g., 30000
   - monthly_contribution (float)
   - reroute_after_target (enum: INVESTMENTS, PREPAY, NONE)

7. InvestmentConfig
   - id
   - scenario_id (FK)
   - base_monthly_contribution (float)
   - annual_return_rate (float)       # e.g. 6.0 for 6%
   - compounding (enum: MONTHLY, ANNUAL)

8. PrepaymentConfig
   - id
   - scenario_id (FK)
   - annual_lump_sum (float)          # amount used for lump sum once/year
   - monthly_extra_payment (float)
   - use_bonus_for_prepay (bool)
   - use_extra_paycheques_for_prepay (bool)
   - prepay_invest_split_percent (float)  # 0–100, percent of surplus going to prepay vs invest

9. ProjectionResult (for storing or returning computed projections if needed)
   - Not necessarily stored permanently; mostly returned by API.
   - Should include:
     - time_step (int, month index)
     - year (int)
     - month (int)
     - mortgage_balance (float)
     - mortgage_payment (float)
     - interest_paid (float for period)
     - principal_paid (float for period)
     - total_interest_paid_to_date (float)
     - home_value (float)
     - home_equity (float)
     - ef_balance (float)
     - investment_balance (float)
     - net_worth (float)
     - monthly_income (float)
     - total_expenses (float)
     - cash_surplus (float)
     - notes/flags (e.g., "TRIGGER_HIT")

You can keep ProjectionResult as an in-memory object returned via API, you don’t have to persist it.

===============================================================================
BUSINESS LOGIC REQUIREMENTS
===============================================================================

Implement domain logic as service functions in `backend/services/`.

---------------------------------------------------------
A. Mortgage Engine (Fixed + Variable, Canada-Focused)
---------------------------------------------------------

Implement a function like:

  simulate_mortgage(mortgage_config, rate_blocks, prime_blocks, prepayment_config, horizon_years) -> list[MonthlyMortgageState]

Where MonthlyMortgageState includes:
- month_index
- year_index
- balance
- interest_rate
- payment_amount
- interest_component
- principal_component
- extra_prepayment
- trigger_hit (bool)
- notes (string)

Rules:

1. **Compounding for Canada**:
   - Default: semi-annual compounding, not in advance.
   - Use standard Canadian mortgage formula:
     - Convert nominal annual rate r_nom (compounded semi-annually) to effective monthly.
     - Then compute payment using amortization formula.

2. **Fixed Rate Mortgages**:
   - Payment is constant within a term (unless prepayment rules explicitly change it).
   - When transitioning to a new RateScheduleBlock:
     - Recalculate payment based on remaining balance and remaining amortization.

3. **Variable (Changing Payment)**:
   - For each rate change:
     - Recalculate payment so that remaining balance amortizes over remaining amortization.
   - Payment can go up/down as Prime changes.

4. **Variable (Fixed Payment) + Trigger Rate**:
   - Initial payment determined as if it’s a fixed rate.
   - When Prime (thus actual rate) changes:
     - Interests per period = rate * balance / 12.
     - Compute how much of the fixed payment is interest vs principal.
   - Trigger:
     - If interest ≥ payment (or some threshold), set trigger_hit = True.
     - For MVP, assume lender forces new payment:
       - Recompute payment to restore original amortization end date.
       - From that month onward, use updated payment.

5. **Prepayments**:
   - Monthly extra payment: add on top of regular payment.
   - Annual lump sum: apply at a specified month each year (e.g., month 12, 24, 36…).
   - When prepayment would exceed remaining principal:
     - Cap at remaining principal and close mortgage.

Make the engine robust for horizons of at least 30 years: up to 360 or more monthly steps.

---------------------------------------------------------
B. Cash Flow Engine
---------------------------------------------------------

Implement:

  simulate_cash_flow(scenario, mortgage_timeline, cashflow_config, ef_config, investment_config, prepayment_config, horizon_years) -> list[MonthlyCashFlowState]

MonthlyCashFlowState should include:
- month_index
- gross_income (base salary / 12 + pro-rated extras if any)
- extra_paycheque (if this month gets an extra paycheque)
- bonus_received (if this month gets bonus)
- fixed_expenses
- variable_expenses
- mortgage_payment (from mortgage_timeline)
- other_debt_payments
- total_expenses
- surplus_before_allocations
- ef_contribution
- investment_contribution
- prepayment_contribution
- ef_balance
- investment_balance
- cash_surplus_after_allocations

Rules:

1. Monthly income:
   - monthly_income field is assumed to represent **normal 2-paycheque income per month**.
   - extra_paycheques_per_year (e.g., 2) are spread evenly across the year:
     - simplest: choose specific months (e.g., months 6 and 12) to receive an extra paycheque (monthly_income / 2).

2. Bonus:
   - annual_bonus applied in one month each year (e.g., month 12).

3. Expenses:
   - total_expenses = fixed_expenses_monthly + variable_expenses_monthly + other_debt_payments + mortgage_payment.

4. Surplus:
   - surplus_before_allocations = income + extra_paycheque + bonus - total_expenses.

5. Allocation order:
   - First to EF, up to `ef_config.monthly_contribution`, but stop when EF target is reached.
   - After EF is full:
     - Based on prepay_invest_split_percent:
       - Some percent to prepayment_contribution (extra principal).
       - Remaining percent to investment_contribution.
   - If surplus is negative, no contributions; dynamic shortfall is allowed (but highlight in output).

---------------------------------------------------------
C. EF Engine
---------------------------------------------------------

- Track EF month by month.
- When EF reaches target_amount, stop contributions.
- After EF is full, contributions are re-routed according to config (investments/prepayments).

---------------------------------------------------------
D. Investment Engine
---------------------------------------------------------

- Simulate monthly compounding:
  - balance_{t+1} = balance_t * (1 + r_monthly) + contributions_t
- r_monthly = (1 + r_annual)^(1/12) - 1, where r_annual is annual_return_rate / 100.
- Combine contributions from:
  - base_monthly_contribution
  - surplus-based contributions when EF is full
  - bonus or extra paycheques if split config says so.

---------------------------------------------------------
E. Net Worth Engine
---------------------------------------------------------

For each month:

- home_value(t) = initial_home_price * (1 + appreciation_rate)^(t/12).
- mortgage_balance(t) = from mortgage simulation.
- home_equity(t) = home_value(t) - mortgage_balance(t).
- net_worth(t) = home_equity(t) + investment_balance(t) + ef_balance(t) - other_debt_principal (if tracked).

Produce:

- monthly net worth list.
- simple derived yearly points (e.g., every 12 months) for charting.

===============================================================================
API DESIGN (BACKEND ENDPOINTS)
===============================================================================

Create a FastAPI router for scenarios and calculations.

1. POST /api/scenarios
   - Create a new scenario with all configs (mortgage, cash flow, EF, investment, prepayment).
   - Body: full ScenarioCreate schema.

2. GET /api/scenarios
   - Return list of scenarios with basic info (id, name, description, timestamps).

3. GET /api/scenarios/{scenario_id}
   - Return full scenario with all configs.

4. PUT /api/scenarios/{scenario_id}
   - Update scenario and its configs.

5. DELETE /api/scenarios/{scenario_id}
   - Soft delete or hard delete (MVP can hard delete).

6. POST /api/scenarios/{scenario_id}/run
   - Run full simulation for that scenario.
   - Returns:
     - monthly timeline for:
       - mortgage
       - cash flow, EF, investment
       - net worth
     - derived yearly summary list for chart usage:
       - year
       - mortgage_balance
       - home_equity
       - ef_balance
       - investment_balance
       - net_worth

7. POST /api/compare
   - Body: { scenario_ids: [id1, id2, id3, id4], horizon_years?: int }
   - For each scenario:
     - Run simulation
     - Extract:
       - payoff_date
       - total_interest_paid
       - net_worth_at_10y (and optionally 20y, 30y)
   - Return an array of summary objects plus “winner” fields (e.g., max_net_worth, min_interest).

===============================================================================
FRONTEND REQUIREMENTS
===============================================================================

Use React + TypeScript + Vite.

Pages:

1. Scenario List Page
   - List saved scenarios with:
     - name
     - key summary metrics (once computed) like:
       - horizon
       - net worth at 10 years (if cached)
   - Button: "Create New Scenario"
   - Click: navigate to Scenario Editor.

2. Scenario Editor Page
   - Multi-step form or tabs:
     - Scenario basics (name, description, horizon_years)
     - Mortgage config
     - Rate schedule & Prime blocks
     - Cash flow config
     - EF config
     - Investment config
     - Prepayment config
   - Buttons:
     - Save scenario
     - "Run Simulation" (calls /run).
   - After running simulation:
     - Show charts & summary in a panel below forms:
       - Net worth over time (line chart)
       - Mortgage balance over time
       - EF & investments growth
       - Monthly cash flow (income vs expenses vs surplus)

3. Comparison Page
   - Dropdown or multiselect of scenarios.
   - Button: "Compare".
   - Use /api/compare endpoint.
   - Show:
     - Table with rows = scenarios, cols = metrics:
       - Payoff date
       - Total interest
       - Net worth (10,20,30 years)
     - Highlight best values in green.
     - Simple bar chart for net worth at year N across scenarios.

4. Dashboard / Landing (optional)
   - Simple page with:
     - CTA to create first scenario.
     - If scenarios exist: show 3 most recently edited.

Frontend should:

- Use reusable form components.
- Provide client-side validation (e.g., no negative numbers).
- Show loading indicators when simulations are running.

===============================================================================
NON-FUNCTIONAL REQUIREMENTS
===============================================================================

- Aim for clear separation of concerns in backend service modules.
- Write at least a few unit tests for the mortgage math functions (if time allows).
- Document key functions (docstrings).
- Make the UI reasonably clean even if not styled heavily.
- Comment code where mortgage/finance formulas appear.

===============================================================================
DELIVERABLE
===============================================================================

At the end, I want:

- A working full-stack app which I can run with:
  - backend: `uvicorn backend.main:app --reload`
  - frontend: `npm install && npm run dev` (or equivalent)
- Ability to:
  - Create/edit scenarios.
  - Run simulations.
  - See charts & summary metrics.
  - Compare multiple scenarios.
- Code that is reasonably clean and understandable so I can extend it later.

Please now scaffold the project, implement the core, and add enough example code and comments so I can easily continue building on top of it.
